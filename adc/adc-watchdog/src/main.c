/**
 * @file        : main.c
 * @brief       : Программа для работы с ADC1 в режиме Analog Watchdog, отслеживающая пороговые значения напряжения на входе A5.
 * @author      : xmatech
 * @date        : 23.01.2025
 * @board       : JZ-F407VET6
 * @MCU         : STM32F407VET6
 * @IDE         : Segger Embedded Studio
 *
 * @Description : Программа настраивает ADC1 для работы в режиме Analog Watchdog, отслеживая напряжение на входе A5 (PA5), 
 *                к которому подключен потенциометр. При выходе напряжения за пределы заданных порогов (10% и 80% от полной шкалы ADC)
 *                включается светодиод LED1 (PE13). Триггером для измерений ADC1 служит сигнал от таймера TIM2, настроенного на частоту 1 кГц.
 *                Программа использует прерывания для обработки событий Analog Watchdog и управления светодиодом.
 *
 *                Основные функции:
 *                • Инициализация тактирования (RCC).
 *                • Настройка таймера TIM2 для генерации триггера с частотой 1 кГц.
 *                • Настройка ADC1 для работы в режиме Analog Watchdog с использованием инжектированного канала.
 *                • Обработка прерываний ADC для управления светодиодом в зависимости от состояния Analog Watchdog.
 */


#include "main.h"


/**
 * @brief Основная функция программы.
 * 
 * Инициализирует систему, настраивает тактирование, таймер TIM2 и ADC1.
 * Основной цикл программы пустой, так как вся работа выполняется в прерываниях.
 */
int main(void) {

  SystemInit(); // Инициализация системы
  rcc_init();   // Настройка тактирования
  tim2_init();  // Инициализация TIM2
  adc1_init();  // Инициализация ADC1
   

while (1) {

    }
}

/**
 * @brief Инициализация таймера TIM2.
 * 
 * Настраивает таймер TIM2 для генерации триггера с частотой 1 кГц.
 * Таймер использует предделитель и период для достижения нужной частоты.
 * Сигнал TRGO генерируется при каждом обновлении таймера.
 */
void tim2_init(void) {

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;            // вкл. тактирования TIM2 (APB1 - 84 МГц)
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;           // вкл. тактирования GPIOE
                                                   
    GPIOE->MODER |= GPIO_MODER_MODE13_0;           // PE13 - выход
    GPIOE->ODR   |= GPIO_ODR_OD13;                 // Выкл. LED(PE13)

    TIM2->PSC     = 8400 - 1;                      // Настройка предделителя на частоту 10 кГц  ( APB2(84 МГц)/PSC(8400-1) = 10 кГц )
    TIM2->ARR     = 10;                            // Настройка периода на частоту - 1кГц (10 кГц/10 = 1 кГц)

    TIM2->CR2    |= (0b011 << TIM_CR2_MMS_Pos);    // TRGO на событие обновления
    TIM2->CR1    &= ~(TIM_CR1_CMS | TIM_CR1_DIR);  // Выранивание по центру | Режим счета вверх
    TIM2->EGR    |= TIM_EGR_UG;                    // Обновление регистров (событие UEV)

    TIM2->CR1    |= TIM_CR1_CEN;                   // Вкл. таймер

}   


/**
 * @brief Инициализация ADC1.
 * 
 * Настраивает ADC1 для работы в режиме Analog Watchdog.
 * Используется инжектированный канал 5 (PA5) для отслеживания напряжения.
 * Настраиваются пороговые значения (10% и 80% от полной шкалы ADC).
 * Триггером для конвертации служит сигнал от таймера TIM2.
 */
void  adc1_init(void) {
    
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;              // Включение тактирования ADC1
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;             // Включение тактирования порта GPIOA
                                                     
    GPIOA->MODER |= GPIO_MODER_MODE5;                // Настройка PA5 как аналоговый вход (ADC1_CH5)
                                                     
    ADC1->SMPR2  |= ADC_SMPR2_SMP5_0;                // выбираем канал конвертирования ADC1 Channel 5  и время конвертирования 15 тактов 
                                                     
    ADC1->JSQR   &= ~(ADC_JSQR_JL);                  // Длина последовательности инжектированных каналов равна 1  
    ADC1->JSQR   |= (5 << ADC_JSQR_JSQ4_Pos);        // Выбор канала 5 для конвертации

    ADC1->CR1    |= ADC_CR1_RES_0;                   // Разрешение АЦП 10 бит 
    ADC1->CR1    |= ADC_CR1_JAWDEN;                  // Включение Analog Watchdog для инжектированных каналов
    ADC1->CR1    |= (5 << ADC_CR1_AWDCH_Pos);        // Настройка канала 5 дял Analog Watchdog      
    ADC1->CR1    |= ADC_CR1_JEOCIE;                  // Включение прерывания для инжектированных каналов

    ADC1->HTR     = 818; // 0x332 (80 % от 3,3V)     // Верхний порог срабатывания Analog Watchdog
    ADC1->LTR     = 102; // 0x066 (10 % от 3,3V)     // Нижний порог срабатывания Analog Watchdog

    ADC1->CR2    |= ADC_CR2_JEXTEN_1;                // Внешний триггер для запуска конвертации
    ADC1->CR2    |= (0b0011 << ADC_CR2_JEXTSEL_Pos); // Триггер от TIM2
     
    NVIC_EnableIRQ(ADC_IRQn);                        // Включение прерывания ADC
    ADC1->CR2    |= ADC_CR2_ADON;                    // Включение ADC

}



/**
 * @brief Обработчик прерывания ADC.
 * 
 * Этот обработчик вызывается при срабатывании прерывания ADC.
 * Он проверяет флаг Analog Watchdog (AWD) и управляет светодиодом LED1 (PE13):
 * - Если флаг AWD установлен (напряжение вышло за пределы порогов), светодиод включается.
 * - Если флаг AWD сброшен (напряжение в пределах порогов), светодиод выключается.
 * После обработки флаги AWD и JEOC сбрасываются, а запрос прерывания очищается.
 */
void ADC_IRQHandler(void) {

  /* Проверка флага Analog Watchdog (AWD) */
   if (ADC1->SR   & ADC_SR_AWD)
       GPIOE->ODR &= ~(GPIO_ODR_OD13);            // Включить LED1, если напряжение вышло за пределы порогов
   else                                             
      GPIOE->ODR  |=  GPIO_ODR_OD13;              // Выключить LED1, если напряжение вернулось в допустимые пределы
      
   ADC1->SR      &= ~(ADC_SR_AWD | ADC_SR_JEOC);  // Сброс флагов AWD и JEOC
    
   NVIC_ClearPendingIRQ(ADC_IRQn);                // Cброс запроса прерывания ADC
}

