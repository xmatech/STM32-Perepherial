/**
 * @file        : tim.c
 * @brief       : Реализация функций для работы с таймерами TIM1 и TIM2.
 * @author      : xmatech
 * @date        : 16.01.2025
 * @board       : JZ-F407VET6
 * @MCU         : STM32F407VET6
 * @IDE         : Segger Embedded Studio
 *
 * @Description : Этот файл содержит функции для инициализации и работы с таймерами TIM1 и TIM2.
 *                TIM1 используется для измерения временного интервала между нажатиями кнопок S1 и S2,
 *                а TIM2 тактирует TIM1 с частотой 1 кГц.
 */
 

#include "main.h"
#include "tim.h"

// Определение глобальных переменных для отслеживания времени
 volatile float capture_s  = 0; // интервал между нажатиями S1 и S2 в секундах
 volatile float capture_ms = 0; // интервал между нажатиями S1 и S2 в милисекундах




/**
 * @brief Инициализация таймера TIM1.
 * @details Настройка таймера TIM1 для работы в режиме захвата входа (Input Capture) на канале 2 (PE11).
 * TIM1 тактируется от TIM2 с частотой 1 кГц.
 */
void tim1_init(void) {

  
  RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;                 // Включение тактирования TIM1 (APB2 - 84 МГц)
                                                      
  /* PE11 - TIM1_CH2 */                               
  GPIOE->MODER   |= GPIO_MODER_MODE11_1;              // Настраиваем PE11 как альтернативную функцию (PE10)
  GPIOE->OSPEEDR |= GPIO_OSPEEDER_OSPEEDR11_1;        // Высокая скорость для PE11
  GPIOE->AFR[1] |= GPIO_AFRH_AFSEL11_0;               // Альтернативная функция для PE11 (TIM1_CH2)

  RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;

  // Настройка источника триггера для таймера TIM1
  TIM1->SMCR |= TIM_SMCR_TS_0;                        // Источник триггера (Internal Trigger 2 - ITR2)  
  TIM1->SMCR |= TIM_SMCR_SMS;                         // Режим ведомого таймера.
  
  TIM1->PSC = 1000;                                   // 1 Гц  
 
  
  TIM1->CR1 &= ~(TIM_CR1_CMS|TIM_CR1_DIR);            // Сброс битов режима (счет от 0 до ARR) | направления счета(счет вверх)

  TIM1->CCMR1 &= ~(TIM_CCMR1_IC2F|TIM_CCMR1_IC2PSC);  // Без фильтра и предделителя 
  TIM1->CCMR1 |= TIM_CCMR1_CC2S_0;                    // CH2 (IC2) - вход, (E11)

  TIM1->CCER |= TIM_CCER_CC2P;                        // Захват по нисходящему фронту (Срабатывает при нажатии кнопки)
  TIM1->CCER |= TIM_CCER_CC2E;                        // Разрешаем захват на канале 2.
                                                      
  TIM1->DIER |= TIM_DIER_CC2IE;                       // Разрешаем прерывание по захвату на СH2
                                                      
  NVIC_EnableIRQ(TIM1_CC_IRQn);                       // Разрешаем прерывание от TIM1_CC (Capture/Compare) в NVIC.

}



/*       
 Выбираем режим  в качестве триггерного выхода (TRGO).
 TRGO будет генерировать импульс при каждом переполнении таймера TIM2.
 Этот импульс будет использоваться для тактирование  TIM1.
╭───────────┬────────────────┬────────────────┬────────────────┬────────────────╮
│ Slave TIM │ ITR0 (TS = 000)│ ITR1 (TS = 001)│ ITR2 (TS = 010)│ ITR3 (TS = 011)│
├───────────┼────────────────┼────────────────┼────────────────┼────────────────┤
│ TIM1      │   TIM5_TRGO    │  TIM2_TRGO     │  TIM3_TRGO     │  TIM4_TRGO     │
│ TIM8      │   TIM1_TRGO    │  TIM2_TRGO     │  TIM4_TRGO     │  TIM5_TRGO     │
╰───────────┴────────────────┴────────────────┴────────────────┴────────────────╯
*/


/**
 * @brief Инициализация таймера TIM2.
 * @details Настройка таймера TIM2 для генерации частоты 1 кГц, которая используется для тактирования TIM1.
 * TIM2 работает в режиме мастера и генерирует импульс при каждом переполнении.
 */
void tim2_init(void) {

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

    TIM2->PSC = 42 - 1 ;                       // Предделитель  для получения частоты 2 МГц (84 Мгц/ 42 = 2 Мгц) 
    TIM2->ARR = 1999;                          // Установка значения автоперезагрузки (2 Мгц/2000 = 1 кГц)                 
    TIM2->CR1 |= TIM_CR1_URS;                  // Событие обновления (UEV) генерируется только при переполнении счетчика.
    TIM2->CR2 |= TIM_CR2_MMS_1;                // Настройка режима мастера (MMS = 010)            
    TIM2->CR1 &= ~(TIM_CR1_CMS | TIM_CR1_DIR); // Сброс битов режима (счет от 0 до ARR) | направления счета(счет вверх)
                                                        
}


/**
 * @brief Обработчик прерывания TIM1 по захвату входа.
 * @details Вычисляет временной интервал между нажатиями кнопок S1 и S2 и сохраняет его в переменных `capture_ms` и `capture_s`.
 * Время измеряется в миллисекундах и секундах с округлением до одного знака после запятой.
 */
void TIM1_CC_IRQHandler(void) {

 capture_ms = (TIM1->CCR2);                   // Время в милисекундах

 capture_s = (float)(TIM1->CCR2) / 1000.0f;   // Время в секундах (формат x.xxx)
 capture_s = ROUND_TO_ONE_DECIMAL(capture_s); // Округление до одного знака после запятой (формат x.x)

 TIM2->CR1 &= ~(TIM_CR1_CEN);                 // Останавливаем TIM2
 TIM1->CR1 &= ~(TIM_CR1_CEN);                 // Останавливаем TIM1

}
